1-> Arrays always come up with a condition that they need continous memory location to be properly implemented.

1.1-> To insert or delete an element from an array we need to shift the remaining elements to fill up the vacant space(in case of deletion) or we need to shift the elements to the right to make space for another one(in case of insertion).

2-> In Linked list elements can be presented at any memory location all we need to do is to maintain the record of their memory address.

2.1-> In Arrays the traversal of elements is easy while it is much more diffuclt in case of linked list on the other hand in linked list the insertion and deletion of elements is way more easy than that of array.

2.1.1-> In array elements can be accessed in constant time,irresepective of their position.

2.1.2-> In linked list we need one extra space for each node as to store the address of next node.Hence we need space to store element as well as to store the address of next node.

2.2-> Linked list can be implemented in C using structures. The structure hence created is of self refrencing type i.e, it refers to itself.

struct Node{
    int data;
    struct Node* next;    //Self refrencing structure
};

2.3-> The time complexity in traversalof linked list in O(n).

2.4->Time complexity while entering elements in the linked list.(Time complexity refers to the time taken by the compiler to perform a specific task)

2.4.1->While inserting an element in the beginning of a linked list the time complexity is O(1). As it does not depends on the number of element present in the linked list before .

2.4.1.1-> The process to insert an element in the beginning of linked list is as follows:-
Step1: Create a node 
Step2: Point the node at the head of the linked list 
Step3: Declare the new node as head

{
struct Node* ptr = (struct Node*) malloc(sizeof(struct Node));
ptr->next = head;
head = ptr;
return head;
}

2.4.2->While inserting in-between any linked list the time complexity to do this is O(n). As we first need to traverse upto that element andonly after that we can insert the element there.

2.4.2.1-> The process to insert an element in-between any linked list is as follows:-
Step1: Create a pointer and make it traverse upto the required node at whivh we have to insert the new node
Step2: Make a new node and point it as required

{
    struct Node* ptr = (struct Node*) malloc(sizeof(struct Node));
    ptr->next = p->next; // p is the pointer variable which we had created earlier for traversal

    //In the above step hum n jo hamara pointer variable p tha uske next part ko jo pahale directly next node ko point kar raha tha ab hum n usse new node se point karwa diya h aur ab agle step m  hum p ke next ko ptr pe point karenge 

    p->next = ptr; 
}

2.4.3->While inserting an element in the end of the list ,first we have to traverse the whole list till ptr->next = NULL As it becomes NULL we can insert the new node there.

2.4.3.1-> The time complexity of this process is O(n) as we need to traverse the whole list first before entering a node there. 

{
    struct Node* ptr = (struct Node*)malloc(sizeof(struct Node));
    p->next = ptr;
    ptr->next = NULL;
}

2.4.4->To insert a node after a node(i.e, we know the address of that particular node after which we have to add the node) the time complexity in doing this is O(1) as we already know the address so irresepective of the number of nodes present in the linkedList we can done this in a constant time.

{
    struct Node* ptr = (struct Node*)malloc(sizeof(struct Node));
    ptr->next = q->next;
    q->next = ptr;

    //q is the node after which we are adding the new node and it is given there that we know the address of q
}

2.4.4.1-> The difference between adding a node in-between and adding a node after a node is that in the first case we doesn't know the address of the particular node after which we have to add the node and in the second case we know that address also.So the only difference is there in terms in time complexity of both the algorithms(NOTE:- Here I have only talk about the algorithm and the time complexity in actual coding the code may differ).

3-> Deleting the node from the linked list.

3.1-> Deleting the node from the beginning. To do this we simply need to make a pointer variable ptr and make it to point the head .Then we need to point head to the next node and free the ptr as follows:

3.1.2->The time complexity of this process is O(1). As every time we are only deleting the first node and this does not depend upon the number of elements present in the list.

{
    struct Node* ptr = head;
    head = head->next;
    free(ptr);
}

3.2->Deleting the node in between.

Step1: To do this first we need to make a pointer variable "p" which first traverse to the node one before the node which needs to be deleted(Just usse ek pahele wale node tak traverse karwana h !!).
Step2: Then make another pointer variable "q" which points as {struct Node* q = p->next;}.(It points to the next of p i.e, the node to be deleted).
Step3: Now perform as follows:

{
    struct Node* p = head;

    {//traverse "p" as directed above}

    struct Node* q = p->next;
    p->next = q->next ;
    free(q);
}

3.3-> To delete the last node.

3.3.1-> To perform this one needs to take two pointer variables at the same time("p" & "q") and traverse q till the last node and p just one less than q. Now point p to NULL and make q free.

{
    p->next = NULL;
    free(q);
}

4->Circular linked list
4.1-> The insertion in a circular linked list is same as doing it in any linked list like the one which we have done earlier above.

Step1=>To start insertion in a circular linked list we have to first create a function of type void and pass the head this time instead of pointer variable ptr.

Step2=>Create a pointer variable ptr and made it point to the head of the linked list.

Step3=>Start a do-while loop this time and traverse the list as done before.

The pesudocode to do all these above steps is as follows:-

void traverse(struct Node* head){
    struct Node* ptr = head;
    do
    {
        printf("Element is %d\n", ptr->data);
        ptr = ptr->next;
    } while (ptr != head);

}
Here we have used do-while loop instead of a while loop because in while loop every time you run any condition it leaves the last node which is pointing to the head again and in do-while loop instead of the above condition if you use (ptr->next != head) it also leaves the last node without traversing it. So it is best optimised to the above given condition(ptr != head).

By any chance if you use this condition with while loop it doesn't start the loop as the ptr always points to the head and you have to forcefully start the loop but as do while loop exectues atleast one time during the execution it will automatically serves the purpose.