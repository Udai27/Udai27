1-> Arrays always come up with a condition that they need continous memory location to be properly implemented.

1.1-> To insert or delete an element from an array we need to shift the remaining elements to fill up the vacant space(in case of deletion) or we need to shift the elements to the right to make space for another one(in case of insertion).

2-> In Linked list elements can be presented at any memory location all we need to do is to maintain the record of their memory address.

2.1-> In Arrays the traversal of elements is easy while it is much more diffuclt in case of linked list on the other hand in linked list the insertion and deletion of elements is way more easy than that of array.

2.1.1-> In array elements can be accessed in constant time,irresepective of their position.

2.1.2-> In linked list we need one extra space for each node as to store the address of next node.Hence we need space to store element as well as to store the address of next node.

2.2-> Linked list can be implemented in C using structures. The structure hence created is of self refrencing type i.e, it refers to itself.

struct Node{
    int data;
    struct Node* next;    //Self refrencing structure
};

2.3-> The time complexity in traversalof linked list in O(n).

2.4->Time complexity while entering elements in the linked list.(Time complexity refers to the time taken by the compiler to perform a specific task)

2.4.1->While inserting an element in the beginning of a linked list the time complexity is O(1). As it does not depends on the number of element present in the linked list before .

2.4.1.1-> The process to insert an element in the beginning of linked list is as follows:-
Step1: Create a node 
Step2: Point the node at the head of the linked list 
Step3: Declare the new node as head

{
struct Node* ptr = (struct Node*) malloc(sizeof(struct Node));
ptr->next = head;
head = ptr;
return head;
}

2.4.2->While inserting in-between any linked list the time complexity to do this is O(n). As we first need to traverse upto that element andonly after that we can insert the element there.

2.4.2.1-> The process to insert an element in-between any linked list is as follows:-
Step1: Create a pointer and make it traverse upto the required node at whivh we have to insert the new node
Step2: Make a new node and point it as required

{
    struct Node* ptr = (struct Node*) malloc(sizeof(struct Node));
    ptr->next = p->next; // p is the pointer variable which we had created earlier for traversal

    //In the above step hum n jo hamara pointer variable p tha uske next part ko jo pahale directly next node ko point kar raha tha ab hum n usse new node se point karwa diya h aur ab agle step m  hum p ke next ko ptr pe point karenge 

    p->next = ptr; 
}

2.4.3->While inserting an element in the end of the list ,first we have to traverse the whole list till ptr->next = NULL As it becomes NULL we can insert the new node there.

2.4.3.1-> The time complexity of this process is O(n) as we need to traverse the whole list first before entering a node there. 

{
    struct Node* ptr = (struct Node*)malloc(sizeof(struct Node));
    p->next = ptr;
    ptr->next = NULL;
}

2.4.4->To insert a node after a node(i.e, we know the address of that particular node after which we have to add the node) the time complexity in doing this is O(1) as we already know the address so irresepective of the number of nodes present in the linkedList we can done this in a constant time.

{
    struct Node* ptr = (struct Node*)malloc(sizeof(struct Node));
    ptr->next = q->next;
    q->next = ptr;

    //q is the node after which we are adding the new node and it is given there that we know the address of q
}

2.4.4.1-> The difference between adding a node in-between and adding a node after a node is that in the first case we doesn't know the address of the particular node after which we have to add the node and in the second case we know that address also.So the only difference is there in terms in time complexity of both the algorithms(NOTE:- Here I have only talk about the algorithm and the time complexity in actual coding the code may differ).

3-> Deleting the node from the linked list.

3.1-> Deleting the node from the beginning. To do this we simply need to make a pointer variable ptr and make it to point the head .Then we need to point head to the next node and free the ptr as follows:

3.1.2->The time complexity of this process is O(1). As every time we are only deleting the first node and this does not depend upon the number of elements present in the list.

{
    struct Node* ptr = head;
    head = head->next;
    free(ptr);
}

3.2->Deleting the node in between.

Step1: To do this first we need to make a pointer variable "p" which first traverse to the node one before the node which needs to be deleted(Just usse ek pahele wale node tak traverse karwana h !!).
Step2: Then make another pointer variable "q" which points as {struct Node* q = p->next;}.(It points to the next of p i.e, the node to be deleted).
Step3: Now perform as follows:

{
    struct Node* p = head;

    {//traverse "p" as directed above}

    struct Node* q = p->next;
    p->next = q->next ;
    free(q);
}

3.3-> To delete the last node.

3.3.1-> To perform this one needs to take two pointer variables at the same time("p" & "q") and traverse q till the last node and p just one less than q. Now point p to NULL and make q free.

{
    p->next = NULL;
    free(q);
}

4->Circular linked list
4.1-> The insertion in a circular linked list is same as doing it in any linked list like the one which we have done earlier above.

Step1=>To start insertion in a circular linked list we have to first create a function of type void and pass the head this time instead of pointer variable ptr.

Step2=>Create a pointer variable ptr and made it point to the head of the linked list.

Step3=>Start a do-while loop this time and traverse the list as done before.

The pesudocode to do all these above steps is as follows:-

void traverse(struct Node* head){
    struct Node* ptr = head;
    do
    {
        printf("Element is %d\n", ptr->data);
        ptr = ptr->next;
    } while (ptr != head);

}
Here we have used do-while loop instead of a while loop because in while loop every time you run any condition it leaves the last node which is pointing to the head again and in do-while loop instead of the above condition if you use (ptr->next != head) it also leaves the last node without traversing it. So it is best optimised to the above given condition(ptr != head).

By any chance if you use this condition with while loop it doesn't start the loop as the ptr always points to the head and you have to forcefully start the loop but as do while loop exectues atleast one time during the execution it will automatically serves the purpose.

5->In doubly linked list we can traverse in both directions but this traversal in both directions comes with a cost of extra memory space for the prev pointer.

5.1->To create a doubly linked list one can do it as follows:-

struct Node{
    int data; // A integer data type to store the data of the node
    struct Node* next; // This pointer points to the next node of the linked list
    struct Node* prev; // This pointer points to the previous node of the linked list
}

6->Stack:-Stack is a ADT type of data structure i.e it is not a primary type of data structure it is created using the primary data structures like structure,linked list and arrays . (Here ADT refers to Abstract data type) 

6.1-> Stack follows LIFO principal (means Last in first out) it has certain basic operations like push to inset element , pop to remove element out of it and some others features like isFull and isEmpty to check condtions whether stack is full or empty before doing operations mentioned above.

6.2-> To use these features we first need to code them in the compiler and then we can use them.They goes like:

[Writing pesudocode here not the full code]

//function to push element in stack
Push(stack s, data){
    isFull(s){
        if returned 1 i.e stack is full element can't be inserted in the stack.
        else {
            top++;
            s.top = data;
        }
    }
}

//Function to pop element from the stack
Pop(stack s){
    isEmpty(s){
        if returned 1 i.e stack is already empty
        else {
            data = s.top
            top--;
        }
    }
}

And for other operations they can be done directly using the loops and pointer and hence not mentioning them here.

6.3-> Stacktop is a function which when called returns the topmost value(element) of the stack.It is defined as follows:-

{
    //For stack top
    return s->arr[s->top];
}

6.4-> Stackbottom is a function which when called returns the bottom value(element) of the stack.It is defined as follows:-

{
    //For stack bottom
    return s->arr[0];
}

6.5-> The time complexity in both the cases is O(1).

6.5.1-> All the operations in stack when implemented using arrays has time complexity of O(1) as they are completed in a constant time irresepective of the size of the array.

6.6-> Linked list can also be used to implement stack and in this case the leftmost side is used for the insertion and deletion operations and also for the others operations as in this case the time complexity is O(1).

6.6.1->We need to set head as top before using the linked list as stack.

6.6.2->Here stack empty condition is when top == NULL.

6.6.3->Theoritically here the stack never becomes full as we can add as many nodes in the linked list we wants but in real world scenario it becomes full when the heap memory becomes exhausted as we are dynamically allocating the memory.

6.6.4->For our convience we can set the custom size of our stack.

7-> Queue => Queue is a type of an abstract data type which can be implemented in various ways such as by using arrays , linked list and also by using other ADTs like stack

7.1-> Queue follows FIFO principal(First In first Out).

7.2-> It has certain basic operations like 
1.enqueue 
2.dequeue
3.first val(to find the first value of the queue)
4.last val(to find the last value of the queue)

7.3->To insert an element in the queue we first need to make a pointer 'back' which initially points at -1 and as we insert element in the queue it increments +1 to the next position and inserts the new element there.This process is completed in O(1) time complexity.

7.4->To delete an element from the queue it needs to be done from the beginning of the queue i.e, position 0. and then shifts all the subsequent elements to the left to fill the vacant space.This process is completed in O(n) time complexity.

7.4.1->To remove the element we first need to increase the frontInd by 1 and the delete the element present at that particular position .

7.5->Here while implementing queue we have to maintain two pointers frontInd and backInd which we need to update while inserting and deleting element from the queue
(Inserting = enqueue && Deleting  = dequeue).

7.5.1->The queue becomes empty when both the frontInd and backInd becomes equal i.e, frontInd = backInd.

7.5.2->The queue becomes full when backInd is equals to (size-1) i.e, backInd = size - 1.

7.6->The enqueue operation code goes like this:-

void enqueue(struct Queue *q, int val)
{
    if (!isFull(q))
    {
        q->r = q->r + 1;
        q->arr[q->r] = val;
    }
    else
    {
        printf("Queue is full\n");
    }
}
Note :- Here we are first checking if the queue is full or not and then we are pushing elements in it. This can also be implemented as:-

void enqueue(struct Queue *q, int val)
{
    if (isFull(q))
    {
        printf("Queue is full\n");
    }
    else
    {
        q->r = q->r + 1;
        q->arr[q->r] = val;
    }
}
Both the cases are same having no major difference between them but for the convience it has been mentioned here.

7.7->The dequeue operation code goes like this:-

int dequeue(struct Queue *q)
{
    int a = -1;
    if (!isEmpty(q))
    {
        q->f++;
        a = q->arr[q->f];
    }
    else
    {
        printf("Queue is empty\n");
    }
    return a;
}

7.8->The traversal code for queue is as follows:-

void traversal(struct Queue*q){
    int i = 0;
    while (i <= q->r)
    {
        printf("%d\t",q->arr[i]);
        i++;
    }
    printf("\n");  
}

8-> Circular Queue using Array : In circular queue we increment circularly i.e i = (i+1)%size in this way we can increment circularly it follows like this 
eg: for an array of size 5 the indexation goes from 0 to 4 and the increment goes like this : i = (0+1)%5 => 1
                                                                                              i = (1+1)%5 => 2
                                                                                              i = (2+1)%5 => 3
                                                                                              i = (3+1)%5 => 4
                                                                                              i = (4+1)%5 => 0
This means as we reach the last index of the array i.e 4 and after incrementing from there the value of i now points to the starting of the array and hence now the array is circular in nature. And hence circular queue can be deployed by using this concept.

8.1->The isFull condition for circular queue is (q->r + 1)%q->size == q->f .It means on circularly incrementing the rear index if it becomes equal to the front index then the circular queue is full 

int isFull(struct circularQueue *q)
{
    if ((q->r + 1) % q->size == q->f)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

8.2->The isEmpty condition of circular queue is same as the linear queue i.e when both the rear and front index of the queue are equal.

int isEmpty(struct circularQueue *q)
{
    if (q->f == q->r)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

8.3->The enqueue operation for the circular queue is as follows 

void enqueue(struct circularQueue *q, int val)
{
    if (isFull(q))
    {
        printf("Queue is full\n");
    }
    else
    {
        q->r = (q->r + 1) % q->size;
        q->arr[q->r] = val;
    }
}

In this method we are first checking wether the queue is full or not and after that we are adding the element in the queue using the above given method.

8.4->The dequeue operation is also same as the one which we had done earlier in the queue 

int dequeue(struct circularQueue *q)
{
    int val = -1;
    if (isEmpty(q))
    {
        printf("Queue is empty\n");
    }
    else
    {
        q->f = (q->f + 1) % q->size;
        val = q->arr[q->f];
    }
    return val;
}

Also here we are first checking whether the queue is empty or not and then dequeueing the element from it.

9->Circular queue using Linked list

9.1->The isFull condition for this is if n == NULL then the queue is full where n is the pointer created to insert the new node in the queue.The enqueue operation follows as below:

void enqueue(int val)
{
    struct Node *n = (struct Node *)malloc(sizeof(struct Node));
    if (n == NULL)
    {
        printf("Queue is full\n");
    }
    else
    {
        n->data = val;
        n->next = NULL;
        if (f == NULL)
        {
            f = r = n;
        }
        else
        {
            r->next = n;
            r = n;
        }
    }
}

9.2->The isEmpty condition for this case is when the f pointer points to NULL.
The dequeue operation follows as below:

int dequeue()
{
    struct Node *ptr = f;
    int val = -1;
    if (f == NULL)
    {
        printf("Queue is empty\n");
    }
    else
    {
        f = f->next;
        val = ptr->data;
        free(ptr);
    }
    return val;
}

NOTE:> DEQueue(Double Ended Queue) is done later on and now moving on Sorting Algorithm......[Video number 47 of the playlist]

11->Sorting Algorithms => We had to choose the algorithm with best time and space complexity for sorting purpose 

NOTE: Inplace sorting-> uses constant space for producing the output[In this method the space required by the algorithm does not depend on the input provided i.e it takes the same space for 5 inputs and also the same space for 500k inputs that is the constant space.]

11.1-> The algorithm used must be stable E.g:> for an array with numbers 6,4,1,2,6 the output must be 1,2,4,6,6 and in this output the 6 occuring in the first place must be occured first in the output that is it must maintain the internal order for same values while sorting.

11.2->The algorithm must be adaptive i.e it should take less time for the already sorted data.

11.3->Bubble sort : In bubble sort we compare two adjacent indices and check for the greater number and the swap the values accordingly.
for e.g; 7,11,9,2,17,4

1st pass :-
    0   1   2   3   4   5

    7   11  9   2   17  4       0,1
    7   9   11  2   17  4       1,2
    7   9   2   11  17  4       2,3
    7   9   2   11  17  4       3,4
    7   9   2   11  4   17      4,5
in the first pass the greatest element i.e 17 comes to the rightmost position in the array and it takes 5 comparisons for this and 5 possibile swaps 

2nd pass :-
    0   1   2   3   4   5

    7   9   2   11  4   17      0,1
    7   2   9   11  4   17      1,2
    7   2   9   11  4   14      2,3
    7   2   9   4   11  17      3,4
in this pass we don't need to compare the index 4,5 as 17 the greatest element is already at it's place and now 11 is also in it's right place

3rd pass :-
    0   1   2   3   4   5

    2   7   9   4   11  17      0,1
    2   7   9   4   11  17      1,2
    2   7   4   9   11  17      2,3
now in the 3rd pass we have done 3 comparisons 

4th pass :-
    0   1   2   3   4   5   

    2   7   4   9   11  17      0,1
    2   4   7   9   11  17      1,2
only 2 comparisons have been made here

5th pass :-
    0   1   2   3   4   5

    2   4   7   9   11  17      0,1
only 1 comparison have been done i.e 0,1 as all the elements are already in there place 

NOTE:- 1->In Bubble sort the number of passes required for the complete sorting is n-1 where 'n' is the number of element present in the array.

       2->The number of comparisons and possible swaps keep going decreasing in the successive passes.

       3->The total number of comparisons made in the whole sorting is n(n-1)/2 and the time complexity for this sorting is O(n^2)[while calculating time complexity we always take into account the worst case scenario]

       4->The bubble sort is a stable sorting algorithm as it maintains the same order in the output as given in the input array.

       5->It's not a recurssive algorithm.

       6->Bubble sort by default is not an adaptive algorithm i.e it does not take advantage of already sorted data. Whenever it encounters any data it goes for the comparisons.But we can make it adaptive by imposing certain conditions and restrictions while coding the algorithm.

11.4->In bubble sort code we first initialise two for loops one for the passes and one for the comparisons and possible swaps.

11.4.1->The first for loop initialise from 0 and goes upto n-1(n = Number of elements).
      ->Inside this loop the second for loop goes from 0 to n-1-i that is for the comparisons as the comparisons in each pass decreases.

void bubblesort(int *a, int n)
{
    int temp;
    for (int i = 0; i < n - 1; i++)// loop for number of passes
    {
        for (int j = 0; j < n - 1 - i; j++)// loop for comparisons
        {
            if (a[j] > a[j + 1]) //comparing the two adjacent numbers
            {
                // swapping the numbers if they are not sorted

                temp = a[j]; 
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}

11.4.2->The above code is improvised so that it took less number of passes and comparisons if the array is already sorted and hence comes with a better time complexity.

The improvised code is  :=

void bubblesort(int *a, int n)
{
    int temp;
    int isSorted = 0;
    for (int i = 0; i < n - 1; i++)
    {
        printf("Number of pass %d\n", i + 1);
        isSorted = 1;
        for (int j = 0; j < n - 1 - i; j++)
        {
            if (a[j] > a[j + 1])
            {
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
                isSorted = 0;
            }
        }
        if (isSorted)
        {
            return;
        }
    }
}

It has a variable isSorted which has been initialise as zero and changes its value only if the data is sorted otherwise retains its original value as 0 and sort the array further.